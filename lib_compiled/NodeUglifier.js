// Generated by CoffeeScript 1.7.1
(function() {
  var NodeUglifier, UGLIFY_SOURCE_MAP_TOKEN, UglifyJS, cryptoUtils, fs, fsExtra, packageUtils, path, saltLength, sh, sugar, _;

  fsExtra = require('fs-extra');

  fs = require('fs');

  _ = require('underscore');

  sugar = require('sugar');

  path = require('path');

  sh = require('execSync');

  packageUtils = require('./libs/packageUtils');

  cryptoUtils = require('./libs/cryptoUtils');

  UglifyJS = require('uglify-js');

  saltLength = 20;

  UGLIFY_SOURCE_MAP_TOKEN = "UGLIFY_SOURCE_MAP_TOKEN";


  /* mergeFileFilter */

  NodeUglifier = (function() {
    function NodeUglifier(mainFile, options) {
      var _i, _results;
      if (options == null) {
        options = {};
      }
      this.options = {
        mergeFileFilter: [],
        newFilteredFileDir: "./lib_external",
        containerName: "cachedModules",
        rngSeed: null,
        licenseFile: null,
        fileExtensions: ["js", "coffee", "json"],
        suppressFilteredDependentError: false
      };
      _.extend(this.options, options);
      this.mainFileAbs = path.resolve(process.cwd(), mainFile);
      if (!fs.existsSync(this.mainFileAbs)) {
        throw new Error("main file not found " + this.mainFileAbs);
      } else {
        console.log("processing main file: " + this.mainFileAbs);
      }
      this.salt = cryptoUtils.generateSalt(saltLength);
      this.hashAlgorithm = "sha1";
      this.wrappedSourceContainerName = this.options.containerName;
      this.serialMappings = cryptoUtils.shuffleArray((function() {
        _results = [];
        for (_i = 0; _i <= 10000; _i++){ _results.push(_i); }
        return _results;
      }).apply(this), this.options.rngSeed);
      this._sourceCodes = {};
      this.statistics = {};
      this.lastResult = null;
    }

    NodeUglifier.prototype.getSourceContainer = function(serial) {
      return this.wrappedSourceContainerName + "[" + this.serialMappings[serial] + "]";
    };

    NodeUglifier.prototype.getRequireSubstitutionForMerge = function(serial) {
      return this.getSourceContainer(serial) + ".exports";
    };

    NodeUglifier.prototype.getNewRelativePathForFiltered = function(pathAbs) {
      return path.join(this.options.newFilteredFileDir, path.basename(pathAbs));
    };

    NodeUglifier.prototype.getRequireSubstitutionForFiltered = function(pathAbs) {
      var relFile, relFileNoExt;
      relFile = this.getNewRelativePathForFiltered(pathAbs);
      relFileNoExt = relFile.replace(path.extname(relFile), "");
      return "require('./" + relFileNoExt.replace("\\", "/") + "')";
    };

    NodeUglifier.prototype.addWrapper = function(source, serial) {
      var firstLine, lastLine, modulesArrayStr, secondLine;
      modulesArrayStr = this.getSourceContainer(serial);
      firstLine = modulesArrayStr + "={exports:{}};" + "\n";
      secondLine = "(function(module,exports) {";
      lastLine = "}).call(this," + modulesArrayStr + "," + modulesArrayStr + ".exports);";
      return "\n" + firstLine + secondLine + source + lastLine;
    };

    NodeUglifier.prototype.merge = function() {
      var filteredOutFiles, firstLine, r, recursiveSourceGrabber, _this;
      _this = this;
      firstLine = "var " + this.wrappedSourceContainerName + "=[];";
      r = {
        source: firstLine,
        filteredOutFilesObj: {},
        sourceMapModules: {}
      };
      filteredOutFiles = packageUtils.getMatchingFiles(this.mainFileAbs, this.options.mergeFileFilter);
      recursiveSourceGrabber = function(filePath) {
        var ast, basename, filteredOutFilesObj, isSourceObjDepFiltered, isSourceObjFiltered, msg, otherSerial, pathSaltedHash, replacement, requireStatement, requireStatements, source, sourceObj, sourceObjDep, _i, _len;
        source = packageUtils.readFile(filePath).toString();
        pathSaltedHash = cryptoUtils.getSaltedHash(filePath, _this.hashAlgorithm, _this.salt);
        if (_this._sourceCodes[pathSaltedHash] == null) {
          _this._sourceCodes[pathSaltedHash] = {
            source: source,
            serial: _.keys(_this._sourceCodes).length,
            sourceMod: source
          };
          console.log(filePath + " added to sources ");
        }
        sourceObj = _this._sourceCodes[pathSaltedHash];
        isSourceObjFiltered = filteredOutFiles.filter(function(fFile) {
          return path.normalize(fFile) === path.normalize(filePath);
        }).length > 0;
        ast = packageUtils.getAst(source);
        requireStatements = packageUtils.getRequireStatements(ast, filePath, _this.fileExtensions);
        requireStatements.each(function(o, i) {
          return requireStatements[i] = _.extend(o, {
            pathSaltedHash: cryptoUtils.getSaltedHash(o.path, _this.hashAlgorithm, _this.salt)
          });
        });
        for (_i = 0, _len = requireStatements.length; _i < _len; _i++) {
          requireStatement = requireStatements[_i];
          sourceObjDep = _this._sourceCodes[requireStatement.pathSaltedHash];
          if (isSourceObjFiltered && packageUtils.getIfNonNativeNotFilteredNonNpm(requireStatement.path, filteredOutFiles, _this.options.fileExtensions)) {
            msg = "filtered files can not have dependency on merged files, file: " + filePath + " dependency: " + requireStatement.path;
            if (_this.options.suppressFilteredDependentError) {
              console.warn(msg);
            } else {
              throw new Error(msg);
            }
          }
          if (sourceObjDep == null) {
            recursiveSourceGrabber(requireStatement.path);
          }
          sourceObjDep = _this._sourceCodes[requireStatement.pathSaltedHash];
          if (sourceObjDep == null) {
            throw new Error(" internal should not happen 1");
          }
          otherSerial = sourceObjDep.serial;
          isSourceObjDepFiltered = filteredOutFiles.filter(function(fFile) {
            return path.normalize(fFile) === path.normalize(requireStatement.path);
          }).length > 0;
          if (isSourceObjDepFiltered) {
            replacement = _this.getRequireSubstitutionForFiltered(requireStatement.path);
          } else {
            replacement = _this.getRequireSubstitutionForMerge(otherSerial);
            r.sourceMapModules[_this.getSourceContainer(otherSerial)] = path.relative(path.dirname(_this.mainFileAbs), requireStatement.path);
          }
          sourceObj.sourceMod = packageUtils.replaceRequireStatement(sourceObj.sourceMod, requireStatement.text, replacement);
        }
        if (isSourceObjFiltered) {
          basename = path.basename(filePath);
          if (r.filteredOutFilesObj[basename]) {
            filteredOutFilesObj = r.filteredOutFilesObj[basename];
            if (filteredOutFilesObj.serial !== sourceObj.serial) {
              throw new Error(" external files with same filename not supported yet");
            }
          } else {
            r.filteredOutFilesObj[basename] = {
              pathRel: _this.getNewRelativePathForFiltered(filePath)
            };
            return _.extend(r.filteredOutFilesObj[basename], sourceObj);
          }
        } else {
          if (sourceObj.serial > 0) {
            sourceObj.sourceModWrapped = _this.addWrapper(sourceObj.sourceMod, sourceObj.serial);
          } else {
            sourceObj.sourceModWrapped = sourceObj.sourceMod;
          }
          return r.source = r.source + sourceObj.sourceModWrapped;
        }
      };
      recursiveSourceGrabber(this.mainFileAbs);
      this.lastResult = r;
      return this;
    };

    NodeUglifier.prototype.toString = function() {
      return this.lastResult.source.toString();
    };

    NodeUglifier.prototype.exportToFile = function(file) {
      var outDirRoot, outFileAbs, _this;
      _this = this;
      outFileAbs = path.resolve(file);
      fsExtra.ensureDirSync(path.dirname(outFileAbs));
      fs.writeFileSync(outFileAbs, this.toString());
      outDirRoot = path.dirname(outFileAbs);
      return _.keys(this.lastResult.filteredOutFilesObj).each(function(fileName) {
        var copyObj, newFile;
        copyObj = _this.lastResult.filteredOutFilesObj[fileName];
        newFile = path.resolve(outDirRoot, copyObj.pathRel);
        fsExtra.ensureDirSync(path.dirname(newFile));
        return fs.writeFileSync(newFile, copyObj.sourceMod);
      });
    };

    NodeUglifier.prototype.exportSourceMaps = function(file) {
      var dir, outFileAbs, sourceMapModulesOutFileName, sourceMapOutFileName, _this;
      _this = this;
      outFileAbs = path.resolve(file);
      sourceMapOutFileName = path.basename(outFileAbs) + ".map";
      sourceMapModulesOutFileName = path.basename(outFileAbs) + ".modules-map";
      dir = path.dirname(outFileAbs);
      fsExtra.ensureDirSync(dir);
      if (this.lastResult.sourceMapUglify != null) {
        fs.writeFileSync(path.join(dir, sourceMapOutFileName), this.lastResult.sourceMapUglify.replace(UGLIFY_SOURCE_MAP_TOKEN, sourceMapOutFileName));
      }
      return fs.writeFileSync(path.join(dir, sourceMapModulesOutFileName), JSON.stringify(_this.lastResult.sourceMapModules));
    };

    NodeUglifier.prototype.uglify = function(optionsIn) {
      var a, ast, options, res, source;
      if (optionsIn == null) {
        optionsIn = {};
      }
      if (!this.lastResult) {
        this.merge();
      }
      options = {
        mangle: true,
        compress: {
          drop_console: false,
          hoist_funs: true,
          loops: true,
          evaluate: true,
          conditionals: true
        },
        output: {
          comments: false
        },
        strProtectionLvl: 0
      };
      _.extend(options, optionsIn);
      if (!this.lastResult.source) {
        return;
      }
      source = this.toString();
      a = 1 + 1;
      res = UglifyJS.minify(source, _.extend({
        fromString: true,
        outSourceMap: UGLIFY_SOURCE_MAP_TOKEN
      }, options));
      this.lastResult.source = res.code;
      this.lastResult.sourceMapUglify = res.map;
      switch (options.strProtectionLvl) {
        case 1:
          ast = packageUtils.getAst(this.lastResult.source);
          this.lastResult.source = packageUtils.getSourceHexified(ast);
      }
      return this;
    };

    return NodeUglifier;

  })();

  module.exports = NodeUglifier;

}).call(this);

//# sourceMappingURL=NodeUglifier.map
